\chapter{基于滑动窗口的实时手势生成自回归训练}
\label{chap:training_strategy}

第\ref{chap:model_architecture}章定义了满足因果约束的单步动作预测器，
用于在给定当前输入与有限历史动作条件下预测下一帧动作。
然而，实际系统需要在闭环自回归条件下连续生成多帧序列，
即模型预测会反复进入后续步骤作为历史条件。
此时早期误差可能随时间累积并导致动作漂移，仅以单步监督难以直接约束这种序列级不稳定性。
因此，本章需要在单步动作预测器之上，引入能够刻画闭环多步生成行为的训练形式，
使模型在自身生成历史上学习更稳定的连续输出。

\section{连续输出序列的构建}

本节描述如何将第\ref{chap:model_architecture}章的单步预测器在片段内部进行闭环自回归展开，从而构造连续生成序列，
并为后续的序列级训练目标提供输入形式，以缓解多帧连续生成中的漂移与不稳定现象。

\subsection{片段切割与前序动作帧}
为提高训练样本覆盖率并增强模型对不同对齐位置的鲁棒性，
我们参考CaMN\cite{beatcamn}采用带重叠的滑动切割方式从长序列中提取训练片段。

具体而言，片段起始位置$s_k$按固定步长$\Delta$滑动：
\begin{equation}
s_k = 1 + (k-1)\Delta,
\label{eq:segment_stride}
\end{equation}

设片段长度为$L$帧，原始动作序列为$\{\bm{v}_t^B\}_{t=1}^{T}$，以及对应的多模态输入特征序列为$\{\bm{z}_t^A, \bm{z}_t^F, \bm{z}_t^H\}_{t=1}^{T}$，
由式\eqref{eq:segment_stride}可得到一组相互重叠的训练片段$\{\bm{V}_k^B, \bm{Z}_k\}$：
\begin{align}
\bm{V}_k^B &= (\bm{v}_{s_k}^B, \bm{v}_{s_k+1}^B, \ldots, \bm{v}_{s_k+L-1}^B),\\
\bm{Z}_k &= \left(\{ \bm{z}_{s_k:t}^A \}_{t=s_k}^{s_k+L-1},\ \{ \bm{z}_{s_k:t}^F \}_{t=s_k}^{s_k+L-1},\ \{ \bm{z}_{s_k:t}^H \}_{t=s_k}^{s_k+L-1}\right),
\label{eq:segment_definition_prefix}
\end{align}

在本文实现中，沿用CaMN的设置取$\Delta=10$帧，以在样本数量与数据冗余之间取得平衡。

此外，由于单步预测器在每个时间步均依赖长度$N$的历史动作条件，
若片段起点不提供初始化历史，将导致生成阶段的首步预测无法构造完整的输入窗口。
因此，需要在每个训练片段的起始位置引入一段前置动作帧，作为已知的历史上下文用于初始化生成过程。

具体而言，将第$k$个片段的动作序列$\bm{V}_k^B$划分为两部分：前置动作帧区间与生成区间。
设前置动作帧长度为$\ell_p$，生成区间长度为$M$。
为保证生成阶段的首步预测具有完整的历史动作条件，前置动作帧长度需满足$\ell_p \ge N$。
本文取最小可行值$\ell_p = N$，因此片段长度为
\begin{equation}
L=\ell_p+M=N+M.
\label{eq:segment_length_prefix}
\end{equation}

为便于后续描述，我们将第$k$个训练片段按时间划分为前置动作帧区间与生成区间。
前置动作帧定义为
\begin{equation}
\bm{V}_k^{pre}
=
(\bm{v}_{s_k}^B,\ \bm{v}_{s_k+1}^B,\ \ldots,\ \bm{v}_{s_k+N-1}^B),
\label{eq:pre_segment_def}
\end{equation}
其用于提供片段起始处的历史条件并初始化生成过程；
生成区间对应的真实动作序列定义为
\begin{equation}
\bm{V}_k^{gen}
=
(\bm{v}_{s_k+N}^B,\ \bm{v}_{s_k+N+1}^B,\ \ldots,\ \bm{v}_{s_k+L-1}^B),
\label{eq:gt_gen_segment_def}
\end{equation}
该区间为模型需要逐帧预测并参与后续训练目标计算的部分。
需要强调的是，前置动作帧在训练阶段取自真实动作序列，作为可观测上下文条件用于初始化历史缓存，其本身不作为生成目标。

\subsection{闭环自回归展开与滑动窗口生成}

在引入前置动作帧后，片段内的生成过程可被建模为一个闭环自回归展开过程。
在该设定下，模型在生成阶段的每一步预测不仅依赖于外部多模态输入，
还将其自身先前生成的动作作为后续预测的历史条件，从而显式刻画连续多帧生成时的误差累积行为。

具体而言，对于第$k$个训练片段，其前$N$帧为前置动作帧，
在生成阶段开始时，模型可获得完整的历史动作条件。
在生成阶段的第一个时间步，历史动作序列完全由真实前置动作帧构成；
随着生成过程的推进，模型在每一步将当前预测结果写入历史动作序列，
使得后续预测逐渐在自身生成的历史条件下进行。
该过程形成一个闭环的自回归生成流程。

为形式化描述上述过程，我们在片段内部采用滑动窗口方式对单步预测器进行展开。
设生成阶段第$m$步对应的全局时间索引为
\begin{equation}
t = s_k + N + m - 1, \quad m = 1, 2, \ldots, M.
\end{equation}
在时间步$t$，模型构造长度为$N{+}1$的因果上下文窗口，
其历史动作部分由最近$N$帧可用动作组成：
\begin{equation}
(\tilde{\bm{v}}_{t-N}^B, \ldots, \tilde{\bm{v}}_{t-1}^B),
\end{equation}
其中$\tilde{\bm{v}}$表示当前可用的动作帧：
在生成初期，它们取自真实前置动作帧；
随着生成推进，历史动作序列中的元素将逐步被模型预测结果所替换。

在每一个时间步，单步预测器以当前因果上下文与跨步递推状态作为输入，
输出当前帧动作预测$\hat{\bm{v}}_{t}^B$。
该预测结果随后被视为新的历史动作，并参与后续时间步的上下文构造，
从而实现预测结果向历史条件的逐步写回。

通过在片段内部重复上述滑动窗口展开过程$M$次，
模型能够逐帧生成一个长度为$M$的连续输出序列：
\begin{equation}
\hat{\bm{V}}_k^{gen}
=
(\hat{\bm{v}}_{s_k+N}^B,\ \hat{\bm{v}}_{s_k+N+1}^B,\ \ldots,\ \hat{\bm{v}}_{s_k+L-1}^B).
\label{eq:generated_segment}
\end{equation}
其与真实生成区间$\bm{V}_k^{gen}$（其定义见式\eqref{eq:gt_gen_segment_def}）在时间上对齐，并作为后续序列级训练目标的输入。

\subsection{逐帧输入形式与历史缓冲机制}
\label{subsec:streaming_buffer}

上一小节从概念上描述了片段内的滑动窗口展开：单步预测器在每个时间步接收一个包含历史动作上下文的因果窗口作为输入。
然而，在实际在线系统中，多模态输入以逐帧流的形式到达，模型在时刻$t$仅能接收当前帧的输入特征，而非显式构造好的历史窗口。
因此，本文在单步预测器外部引入历史动作缓冲机制，用于在逐帧输入条件下维护长度为$N$的历史动作上下文，并据此构造预测器所需的因果输入窗口。

\paragraph{历史动作缓存}
我们维护一个历史动作缓存$\mathcal{H}$，用于存储当前可用的最近$N$帧动作：
\begin{equation}
\mathcal{H}_{t-1} = (\tilde{\bm{v}}_{t-N}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}),
\label{eq:history_buffer_stream}
\end{equation}
其中$\tilde{\bm{v}}$表示当前可用的动作帧：在预热阶段取真实前置动作帧，在生成阶段则逐步由模型预测结果覆盖。
在时间步$t$，我们将缓存中的历史动作与当前可观测多模态输入共同组织为长度为$N{+}1$的因果上下文窗口，
并构造融合输入序列$\bm{Z}_t^{fuse}$（其定义见式\eqref{eq:fuse_sequence}）。
其中历史动作序列部分采用
$(\tilde{\bm{v}}_{t-N}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}, \mathbf{0})$
进行对齐，末帧使用占位符以保证严格因果性。

\paragraph{预热阶段与生成阶段}
在片段起点$s_k$，我们首先进行预热阶段：将前置动作帧$\bm{V}_k^{pre}$写入历史动作缓存$\mathcal{H}$，并同步读取对应的多模态输入特征。
预热阶段不产生生成输出，其作用是为生成阶段构造完整的历史动作条件。
生成阶段开始后，模型在每个时间步调用单步预测器，得到当前帧动作预测$\hat{\bm{v}}_{t}^{B}$，并将其写回历史动作缓存：
\begin{equation}
\mathcal{H}_{t} = (\tilde{\bm{v}}_{t-N+1}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}, \hat{\bm{v}}_{t}^{B}),
\label{eq:history_update_stream}
\end{equation}
从而使后续预测逐步在模型自身生成的历史条件下进行。

\paragraph{训练时的逐帧展开与序列拼接}
在训练时，我们将每个长度为$L$的片段按时间顺序拆解为逐帧输入流：模型在每个时间步接收当前帧的多模态输入特征，并通过上述历史缓存机制构造$\bm{Z}_t^{fuse}$以完成预测。
在生成阶段的$M$个时间步上，我们收集逐帧输出$\hat{\bm{v}}_{t}^{B}$并沿时间维拼接，得到与生成区间对齐的连续预测序列$\hat{\bm{V}}_k^{gen}$，
该序列将作为后续监督损失与对抗判别的输入对象。
由于训练与推理阶段均采用相同的逐帧输入组织方式与历史维护机制，上述展开过程能够在实现层面减少由输入组织差异引入的额外偏差。

\subsection{显式历史与隐式状态的跨步协同}
\label{subsec:state_carry_over}

在片段内进行闭环自回归展开时，模型需要连续生成$M$帧动作，并在每一步以自身预测写回历史动作缓存作为后续条件输入。
尽管本文显式提供了长度为$N$的历史动作上下文$\mathcal{H}$作为短期条件，但该显式历史的时间范围固定，无法覆盖更长时域的动态信息。
若每一步预测均以独立窗口、且不保留跨步递推状态，则模型只能依赖有限长度的历史序列来推断当前的运动趋势与节奏信息，
容易导致长序列生成中出现信息截断与状态漂移。

单向LSTM的递推状态$(\bm{h},\bm{c})$提供了一条跨步的长期记忆通道：它能够在滑动窗口持续推进的过程中累积更长时域的运动动态与风格线索，并在每一步预测中以状态形式传递给下一步。
因此，在“显式短期历史（长度$N$）+ 隐式长期状态（跨步传递）”的双时间尺度记忆结构下，模型既能利用最近$N$帧的局部运动细节保持短期连续性，又能通过递推状态保留超出窗口范围的长期依赖，从而更有利于闭环多步生成的稳定性。

具体而言，在时间步$t$，单步因果预测器以融合输入序列$\bm{Z}_t^{fuse}$及上一时间步的递推状态作为输入，输出当前帧动作预测并更新状态：
\begin{equation}
\hat{\bm{v}}_{t}^{B},\ (\bm{h}_{t}, \bm{c}_{t})
= f_{\theta}(\bm{Z}_t^{fuse},\ \bm{h}_{t-1},\ \bm{c}_{t-1}).
\label{eq:one_step_predictor_state_rollout}
\end{equation}
其中$(\bm{h}_t,\bm{c}_t)$表示生成器中LSTM解码器的隐藏状态与记忆单元状态（若包含躯干与上肢两路解码器，则该状态为两路状态的集合）。
在片段内展开过程中，我们在每一步预测后保留并传递更新后的$(\bm{h}_t,\bm{c}_t)$至下一步，从而实现跨步递推。

对于片段起点$s_k$，生成阶段的初始状态采用预设初始化值给出。
本文采用零初始化作为$(\bm{h}_{s_k+N-1},\bm{c}_{s_k+N-1})$的初值，并在随后的$M$步自回归展开中递推更新该状态。

\section{监督损失}
\label{sec:segment_losses}

上一节给出了片段内部的闭环自回归展开过程：模型在每个训练片段中以前置动作帧$\bm{V}_k^{pre}$初始化历史动作条件，
并在生成阶段逐帧滚动预测，将预测结果写回历史缓存；通过上述展开，最终得到与生成区间对齐的连续预测序列$\hat{\bm{V}}_k^{gen}$。
在此基础上，本节进一步定义用于训练生成器的监督损失项。

\subsection{生成区间与损失计算范围}
\label{subsec:segment_level_loss_scope}

对于第$k$个训练片段，其长度为$L=N+M$（第\ref{subsec:fixed_length_segment}节），其中前$N$帧为前置动作帧$\bm{V}_k^{pre}$，后$M$帧为生成区间。
根据第\ref{subsec:sliding_window_rollout_process}节的闭环展开过程，模型得到生成区间的预测序列：
\begin{equation}
\hat{\bm{V}}_k^{gen}
=
(\hat{\bm{v}}_{s_k+N}^{B},\ \hat{\bm{v}}_{s_k+N+1}^{B},\ \ldots,\ \hat{\bm{v}}_{s_k+L-1}^{B})
\in \mathbb{R}^{M \times d},
\label{eq:pred_gen_segment_seq}
\end{equation}
其中$d$表示动作表示的维度（本文使用Rot6D\cite{rot6d}，即$d=6$）。
与之时间对齐的真实生成区间动作序列为：
\begin{equation}
\bm{V}_k^{gen}
=
(\bm{v}_{s_k+N}^{B},\ \bm{v}_{s_k+N+1}^{B},\ \ldots,\ \bm{v}_{s_k+L-1}^{B})
\in \mathbb{R}^{M \times d}.
\label{eq:gt_gen_segment_seq}
\end{equation}

\subsection{总体优化目标}
\label{subsec:total_objective}

综合考虑空间重构精度、时序平滑性以及动作分布一致性，本文的总体优化目标定义为：
\begin{equation}
\mathcal{L}_{total} =
\lambda_r  \mathcal{L}_{rec}
+ \lambda_v \mathcal{L}_{vel}
+ \lambda_a \mathcal{L}_{acc}
+ \lambda_{adv} \mathcal{L}_{adv},
\label{eq:loss_total_seg}
\end{equation}
其中$\mathcal{L}_{rec}$衡量生成区间的姿态重构误差，
$\mathcal{L}_{vel}$与$\mathcal{L}_{acc}$分别约束速度与加速度的连续性，
$\mathcal{L}_{adv}$表示对抗训练损失，将在第\ref{sec:adv_training}节中进一步介绍。

\subsection{姿态重构与时序平滑损失}
\label{subsec:reconstruction_smoothness_loss}

为同时保证空间重构精度与时间连续性，我们采用基于Huber误差的重构损失形式，并分别作用于姿态、速度与加速度信号。
给定任意预测序列$\hat{\bm{X}}$及其对应的真实序列$\bm{X}$，基础误差项定义为：
\begin{equation}
\mathcal{L}_{Huber}(\bm{X}, \hat{\bm{X}})
=
\beta \cdot
\mathrm{SmoothL1}
\left(
\frac{\bm{X}}{\beta},
\frac{\hat{\bm{X}}}{\beta}
\right),
\label{eq:huber_loss}
\end{equation}
其中$\mathrm{SmoothL1}(\cdot)$表示平滑L1误差，$\beta$为平滑系数，本文中设为$0.1$。

\paragraph{姿态重构损失}
生成区间的姿态重构损失定义为：
\begin{equation}
\mathcal{L}_{rec} = \mathcal{L}_{Huber}(\bm{V}_k^{gen},\ \hat{\bm{V}}_k^{gen}).
\label{eq:rec_loss}
\end{equation}

\paragraph{速度与加速度平滑损失}
为约束时间平滑性，我们进一步对生成区间的速度与加速度信号施加同类误差约束。
首先定义一阶与二阶时间差分算子$\nabla(\cdot)$与$\nabla^2(\cdot)$，对任意序列$\bm{X}$有：
\begin{align}
\nabla \bm{X}_t &= \bm{X}_t - \bm{X}_{t-1},\\
\nabla^2 \bm{X}_t &= \nabla \bm{X}_t - \nabla \bm{X}_{t-1}.
\label{eq:diff_def}
\end{align}
对应地，生成区间的速度与加速度损失定义为：
\begin{align}
\mathcal{L}_{vel} &= \mathcal{L}_{Huber}(\nabla \bm{V}_k^{gen},\ \nabla \hat{\bm{V}}_k^{gen}),
\label{eq:vel_loss}\\
\mathcal{L}_{acc} &= \mathcal{L}_{Huber}(\nabla^2 \bm{V}_k^{gen},\ \nabla^2 \hat{\bm{V}}_k^{gen}).
\label{eq:acc_loss}
\end{align}

上述多尺度重构约束在闭环自回归展开过程中能够有效缓解高频抖动与速度漂移问题，
在保证运动学精度的同时提升生成序列的时间稳定性。

\subsection{损失权重设置}
各损失项的权重系数在实验中设定为
$\lambda_r = 5\times10^{2}$，
$\lambda_v = 10^{3}$，
$\lambda_a = 10^{3}$，
$\lambda_{adv} = 10^{-1}$。

\section{对抗训练}
\label{sec:adv_training}

尽管第\ref{sec:segment_losses}节的监督损失能够约束生成序列在逐帧空间误差与局部平滑性上的一致性，
但仅依赖点对点重构目标往往难以完全刻画真实动作序列的整体动力学分布。
为进一步提升生成动作的自然度与分布一致性，本文引入片段级判别器，在序列尺度上约束生成区间的预测序列与真实序列在统计特性上的一致性。

\subsection{片段级判别器输入}
\label{subsec:disc_input}

本文的判别器直接以生成区间的动作序列作为输入。
对于第$k$个训练片段，生成器输出的预测序列$\hat{\bm{V}}_k^{gen}$及其对应的真实序列$\bm{V}_k^{gen}$分别定义见式\eqref{eq:pred_gen_segment_seq}与式\eqref{eq:gt_gen_segment_seq}，
二者均为长度$M$的序列。
判别器$Dis(\cdot)$接收一段动作序列，并输出其来自真实数据分布的概率：
\begin{equation}
Dis(\bm{V}) \in (0,1).
\end{equation}
通过序列级输入，判别器能够从整体动力学角度判断生成动作的真实感，从而在节奏、能量变化与运动统计特性等层面提供补充监督信号。

\paragraph{前置动作帧的掩码策略}
与CaMN\cite{beatcamn}不同，本文在对抗训练中仅对生成区间进行判别，
即判别器的输入不包含片段起始的前置动作帧$\bm{V}_k^{pre}$。
该策略使对抗目标严格作用于模型实际需要生成的部分，并与监督损失的计算范围保持一致。

\subsection{对抗损失定义}
\label{subsec:bce_gan_loss}

判别器的训练目标是区分真实序列与生成序列，其损失定义为：
\begin{equation}
\mathcal{L}_{D} =
-\mathbb{E}_{\bm{V}_k^{gen}}\big[\log Dis(\bm{V}_k^{gen})\big]
-\mathbb{E}_{\hat{\bm{V}}_k^{gen}}\big[\log \big(1 - Dis(\hat{\bm{V}}_k^{gen})\big)\big].
\label{eq:disc_loss_bce}
\end{equation}
生成器则希望其输出被判别器判定为真实，从而对应的对抗损失为：
\begin{equation}
\mathcal{L}_{adv} =
-\mathbb{E}_{\hat{\bm{V}}_k^{gen}}\big[\log Dis(\hat{\bm{V}}_k^{gen})\big].
\label{eq:gen_adv_loss_bce}
\end{equation}
其中$\mathbb{E}_{\bm{V}_k^{gen}}$与$\mathbb{E}_{\hat{\bm{V}}_k^{gen}}$分别表示对真实序列与生成序列的采样期望。
该对抗目标从分布层面鼓励生成序列在整体运动统计特性上接近真实数据，从而补充监督损失在局部误差上的约束。

\subsection{交替优化策略}
\label{subsec:alternating_optimization}

在训练过程中，本文采用交替优化方式更新生成器与判别器。
具体而言，对于每个训练批次，我们首先固定生成器参数$\theta$，最小化式\eqref{eq:disc_loss_bce}更新判别器参数；
随后固定判别器参数，最小化总体损失$\mathcal{L}_{total}$（见式\eqref{eq:loss_total_seg}）更新生成器参数，
其中对抗项$\mathcal{L}_{adv}$由式\eqref{eq:gen_adv_loss_bce}给出。
通过上述训练方式，判别器不断提升对真实与生成序列的区分能力，
而生成器则在监督约束与分布约束的共同作用下，逐步生成更加自然且时间一致的动作序列。

\section{本章小结}
\label{sec:chapter4_summary}

本章围绕单步预测器的闭环自回归训练展开，给出了片段内部连续生成序列的构建方式。
具体而言，我们沿用基线的重叠片段切割策略，并引入长度为$N$的前置动作帧用于初始化历史动作条件；
在此基础上，通过滑动窗口逐帧展开与历史写回机制，得到与生成区间对齐的连续预测序列$\hat{\bm{V}}_k^{gen}$。
随后，本章在生成区间上定义了监督损失与片段级对抗判别目标，使训练信号直接作用于模型需要生成的部分，从而为闭环多帧生成的稳定性提供序列级约束。
