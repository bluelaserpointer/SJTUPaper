\chapter{基于滑动窗口的实时手势生成自回归训练}
\label{chap:training_strategy}

本章讨论在严格因果约束下，如何将第\ref{chap:model_architecture}章定义的窗口内单步预测模型展开为逐帧自回归生成过程，并构建与之对应的训练目标。
由于实时场景无法观测未来的多模态输入，模型必须在每个时间步仅依赖历史信息预测下一帧动作，从而保证在线推理的一致性与可部署性。
为此，本文提出片段切割与滑动窗口展开的流程：通过前置动作帧缓冲历史上下文，并在生成阶段逐帧预测与写回动作缓存，形成连续的片段级输出序列。
在此基础上，本章进一步给出片段级监督损失与对抗训练目标的定义。

\section{单步因果LSTM预测器}
\label{sec:one_step_lstm}

为实现严格因果的实时手势生成，本章首先建立一个用于“下一帧动作预测”的基本单元：单步因果LSTM预测器。
该预测器在每个时间步利用当前可用的多模态输入特征，并结合历史动作上下文与循环状态，对下一帧动作进行估计。
在后续章节中，我们将该单步预测器以滑动窗口方式展开，从而形成对一个动作片段的自回归生成过程，并据此定义片段级别的监督损失与对抗训练目标。

\subsection{LSTM基本概念与状态传递机制}
\label{subsec:lstm_basics}

手势动作序列具有显著的时间依赖性：当前姿态不仅受当前输入模态（如语音、面部表情、头部姿态等）影响，也与过去的动作状态密切相关。
循环神经网络（Recurrent Neural Network, RNN）通过引入随时间递推的隐状态来建模序列依赖，而LSTM进一步通过门控机制缓解长序列训练中的梯度消失问题，从而更适合用于动作序列建模。

在标准的LSTM结构中，网络在每个时间步接收当前输入特征$\bm{x}_t$，并维护两类递推状态：隐藏状态$\bm{h}_t$与记忆单元状态$\bm{c}_t$。
其中，$\bm{h}_t$可视为与当前输出相关的短期表示，而$\bm{c}_t$作为更稳定的记忆轨道，用于在更长时间尺度上保留信息。
其递推过程可形式化表示为：
\begin{equation}
(\bm{h}_t, \bm{c}_t) = \mathrm{LSTM}(\bm{x}_t, \bm{h}_{t-1}, \bm{c}_{t-1}).
\label{eq:lstm_step}
\end{equation}

根据隐状态传播方向的不同，LSTM主要分为单向LSTM（Unidirectional LSTM）与双向LSTM（Bidirectional LSTM）。

双向LSTM通过同时构建前向与反向递推路径，在输出时刻$t$的表示时会融合来自未来时间步的反向信息。
该结构在离线分析或全序列可见的任务中能够更充分利用上下文，从而提升预测性能；然而在实时生成任务中，未来输入在时刻$t$尚不可用，反向路径的依赖无法满足。

相比之下，单向LSTM沿时间正向递推，其状态更新仅依赖于过去与当前输入，从结构上满足因果约束。
对于下一帧动作生成问题，UniLSTM能够自然地被解释为一个逐步更新的预测器：在每个时间步基于当前可观测输入与历史状态输出下一帧动作估计，并将生成结果反馈至下一步，从而形成自回归（autoregressive）的实时生成流程。
此外，单向递推的状态传递机制也使得模型能够在有限的输入上下文之外保留更长程的动态信息，为后续滑动窗口展开提供了必要的记忆能力。

基于以上原因，本文采用单向LSTM作为动作生成的时序建模骨干网络，以满足严格因果的实时生成需求。
在后续的滑动窗口展开策略中（见第\ref{sec:sliding_window_rollout}节），该单步预测器将被逐帧迭代调用，从而在片段级别完成动作序列的自回归生成，并用于定义监督损失与对抗训练目标。

\subsection{双时间尺度记忆结构}
\label{subsec:dual_path_memory}

尽管单向LSTM通过递推状态$(\bm{h}_t,\bm{c}_t)$在理论上具备建模长程依赖的能力，但在自回归动作生成任务中，若仅依赖循环状态作为唯一的历史信息通道，将迫使该状态同时承担短期细节与长期规律的表征。
由于循环状态本质上是对历史信息的压缩表示，其容量有限且受LSTM的门控遗忘机制影响，短期运动细节与局部连续性约束可能难以稳定保留，从而使生成过程更易出现抖动、漂移或长期一致性下降等现象。
因此，本文在跨步循环状态之外显式提供固定长度的历史动作上下文，作为短期约束信号，以在保持长期记忆能力的同时增强逐帧预测的稳定性与可控性。

为提升逐帧生成的稳定性，本文在循环状态之外显式引入固定长度的历史动作上下文作为短期条件信息。
具体而言，设$N$为历史动作上下文长度，在预测时刻$t$的动作时，我们显式提供最近$N$帧的动作历史序列$\bm{v}_{t-N:t-1}^{B}$作为可观测输入，使模型在每一步预测中均能获得短期运动细节与局部连续性约束。
为保持因果性，该历史动作序列不包含当前待预测时刻$t$的真实动作，而采用占位符进行对齐（例如以零向量或掩码符号表示），从而形成长度为$N{+}1$的因果上下文序列。

在该设计下，模型的历史信息将通过两条互补路径传递：一方面，循环状态$(\bm{h},\bm{c})$作为长期记忆通道，用于编码超过$N$帧范围的更长程动态趋势、说话风格与运动节奏；另一方面，显式历史动作上下文作为短期精确条件，在每一步预测中直接提供最近$N$帧的局部运动信息，从而缓解状态漂移带来的不确定性，并提升自回归生成的鲁棒性。
本文采用“短期显式上下文 + 长期隐式状态”的双时间尺度记忆结构，以在严格因果约束下平衡表达能力与生成稳定性。

\subsection{窗口内预测过程的形式化表达}
\label{subsec:window_forward_formalization}

本节将第\ref{chap:model_architecture}章定义的窗口内解码结构形式化为可递推的单步因果预测器，以明确在线生成时循环状态的跨步传递方式。
在时刻$t$，模型以长度为$N{+}1$的因果上下文输入序列$\bm{Z}_t^{fuse}$作为输入（其定义见式\eqref{eq:fuse_sequence}），并分别维护躯干与上肢的LSTM隐藏状态与记忆单元状态：
$(\bm{h}_{t-1}^{T}, \bm{c}_{t-1}^{T})$与$(\bm{h}_{t-1}^{U}, \bm{c}_{t-1}^{U})$。

在在线运行时，我们将跨步传递的状态作为LSTM解码器的初始状态，从而得到窗口内输出序列并更新状态：
\begin{align}
\bm{O}_t^{T}, (\bm{h}_{t}^{T}, \bm{c}_{t}^{T}) &= \mathrm{LSTM}_{T}(\bm{Z}_t^{fuse}, \bm{h}_{t-1}^{T}, \bm{c}_{t-1}^{T}), \\
\bm{O}_t^{U}, (\bm{h}_{t}^{U}, \bm{c}_{t}^{U}) &= \mathrm{LSTM}_{U}(\bm{Z}_t^{fuse}, \bm{h}_{t-1}^{U}, \bm{c}_{t-1}^{U}).
\label{eq:lstm_state_forward}
\end{align}

由于本文在时刻$t$的目标是预测当前帧动作，我们使用窗口末端输出作为当前帧潜在表征，并通过MLP解码得到$\hat{\bm{v}}_{t}^{T}$与$\hat{\bm{v}}_{t}^{U}$，最终拼接为$\hat{\bm{v}}_{t}^{B}$。
该过程已在第\ref{subsec:output_modality_decoding}节给出，此处不再赘述。

因此，可以将单步因果预测器抽象为如下递推形式：
\begin{equation}
\hat{\bm{v}}_{t}^{B},\ (\bm{h}_{t}, \bm{c}_{t})
= f_{\theta}(\bm{Z}_t^{fuse},\ \bm{h}_{t-1},\ \bm{c}_{t-1}),
\label{eq:one_step_predictor_state}
\end{equation}
其中$(\bm{h}_t,\bm{c}_t)$表示躯干、上肢LSTM状态的集合。
在第\ref{sec:sliding_window_rollout}节中，我们将进一步描述该单步预测器如何随时间滑动展开，从而在片段尺度上生成长度为$M$的动作序列，并用于定义监督损失与对抗训练目标。

\section{训练片段切割}
\label{sec:segment_construction}

本工作沿用CaMN采用的训练样本构造方式\cite{beatcamn}，将长序列动作数据切割为固定长度的短片段作为训练样本。

\subsection{固定长度片段定义}
\label{subsec:fixed_length_segment}

设原始动作序列为$\{\bm{v}_t^B\}_{t=1}^{T}$，以及对应的多模态输入特征序列$\{\bm{z}_t^A, \bm{z}_t^F, \bm{z}_t^H\}_{t=1}^{T}$。
我们从长序列中截取长度为$L$的连续片段作为训练样本，其中片段长度由历史上下文长度$N$与片段内生成步数$M$共同决定：
\begin{equation}
L = N + M.
\label{eq:segment_length}
\end{equation}
在本文设定中，沿用CaMN的片段长度配置取$L=34$帧，同时选取历史上下文长度$N=16$帧，因此对应的片段内自回归生成步数为$M=18$帧。

对于第$k$个训练片段，其时间范围为$[s_k, s_k + L - 1]$，片段内的动作与多模态输入分别表示为：
\begin{align}
\bm{V}_k^B &= (\bm{v}_{s_k}^B, \bm{v}_{s_k+1}^B, \ldots, \bm{v}_{s_k+L-1}^B), \\
\bm{Z}_k &= \left(\{ \bm{z}_{s_k:t}^A \}_{t=s_k}^{s_k+L-1},\ \{ \bm{z}_{s_k:t}^F \}_{t=s_k}^{s_k+L-1},\ \{ \bm{z}_{s_k:t}^H \}_{t=s_k}^{s_k+L-1}\right).
\label{eq:segment_definition}
\end{align}
其中$\bm{V}_k^B$将进一步划分为两部分：前$N$帧作为片段的历史上下文（亦即前置动作帧，用于缓冲与提供因果条件），后$M$帧为片段内需要逐帧生成并参与训练目标计算的部分。
该划分将于第\ref{sec:sliding_window_rollout}节中用于描述滑动窗口展开过程与片段级损失计算策略。

\subsection{重叠切割与样本覆盖}
\label{subsec:overlap_sampling}

为提高训练样本覆盖率并增强模型对不同对齐位置的鲁棒性，我们采用带重叠的滑动切割方式从长序列中提取片段。
具体而言，片段起始位置$s_k$按固定步长$\Delta$滑动：
\begin{equation}
s_k = 1 + (k-1)\Delta,
\label{eq:segment_stride}
\end{equation}
从而得到一组相互重叠的训练片段$\{\bm{V}_k^B, \bm{Z}_k\}$。
在本文实现中，沿用CaMN的设置取$\Delta=10$帧，以在样本数量与数据冗余之间取得平衡。

\section{片段内部的滑动窗口展开策略}
\label{sec:sliding_window_rollout}

上一节定义了训练样本以固定长度片段组织：每个片段长度为$L=N+M$，其中前$N$帧为历史上下文，后$M$帧为需要逐帧生成的目标区间。
本节进一步描述片段内部的滑动窗口展开策略：该策略在训练与推理阶段保持一致，以单步因果预测器（第\ref{sec:one_step_lstm}节）为基本计算单元，逐帧生成长度为$M$的动作序列并拼接得到片段级输出。
在本文设定中，$L=34$，$N=16$，因此$M=18$，窗口长度为$N{+}1=17$。

\subsection{前置动作帧与预热阶段}
\label{subsec:warmup_prefix_frames}

在严格因果的实时生成中，模型在时刻$t$预测动作时不能访问未来输入，并且其输出需要在片段之间保持连续。
为此，我们将每个片段的前$N$帧动作视为前置动作帧，其作用是为后续生成提供短期运动上下文，并避免片段边界处出现断裂。

在片段开始时刻$s_k$，我们首先执行预热阶段：将片段的前$N$帧真实动作$\{\bm{v}_{s_k}, \ldots, \bm{v}_{s_k+N-1}\}$写入历史动作缓存$\mathcal{H}$，并同步读取对应的多模态输入特征。
本文在预热阶段不执行任何前向计算，生成阶段的初始LSTM状态由预设初始化值给出。
本文采用零初始化作为$(\bm{h}_{t-1}, \bm{c}_{t-1})$的初值。

\subsection{滑动窗口展开与逐帧自回归生成}
\label{subsec:sliding_window_rollout_process}

在预热阶段结束后，我们进入生成阶段：模型在片段内部进行$M$步滑动窗口展开，每一步生成1帧动作，并将预测结果写回历史动作缓存以供下一步使用。
设片段内生成阶段的第$m$步对应全局时间$t = s_k + N - 1 + m$（其中$m=1,2,\ldots,M$），历史动作缓存$\mathcal{H}_{t-1}$包含最近$N$帧可用动作序列：
\begin{equation}
\mathcal{H}_{t-1} = (\tilde{\bm{v}}_{t-N}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}),
\label{eq:history_buffer}
\end{equation}
其中$\tilde{\bm{v}}$表示当前可用的动作帧：在生成开始时它包含真实前置动作帧，在生成推进过程中则逐渐由模型预测结果覆盖。

在时间步$t$，我们构造长度为$N{+}1$的因果上下文窗口，组合当前可观测的多模态输入特征与历史动作缓存，形成融合输入序列$\bm{Z}_t^{fuse}$（其定义见式\eqref{eq:fuse_sequence}）。
其中历史动作序列部分采用$(\tilde{\bm{v}}_{t-N}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}, \mathbf{0})$进行对齐，末帧使用占位符以保证严格因果性。

随后，单步因果预测器以$\bm{Z}_t^{fuse}$与跨步LSTM状态作为输入，输出当前帧动作预测$\hat{\bm{v}}_{t}^{B}$并更新状态（窗口内形式化表达见第\ref{subsec:window_forward_formalization}节）。
生成结果$\hat{\bm{v}}_{t}^{B}$会被写回历史动作缓存，从而更新$\mathcal{H}_t$并用于下一时间步预测：
\begin{equation}
\mathcal{H}_{t} = (\tilde{\bm{v}}_{t-N+1}^{B}, \ldots, \tilde{\bm{v}}_{t-1}^{B}, \hat{\bm{v}}_{t}^{B}).
\label{eq:history_update}
\end{equation}
通过上述逐帧自回归展开，我们得到片段内生成区间的预测序列：
\begin{equation}
\hat{\bm{V}}_k^{gen} = (\hat{\bm{v}}_{s_k+N}^{B},\ \hat{\bm{v}}_{s_k+N+1}^{B},\ \ldots,\ \hat{\bm{v}}_{s_k+L-1}^{B}),
\label{eq:generated_segment}
\end{equation}
其长度为$M$。

\subsection{拼接生成序列与片段级输出}
\label{subsec:segment_level_output}

由于滑动窗口展开在每一步仅生成1帧动作，片段级输出通过对$M$步预测结果进行时间维拼接获得。
片段级生成结果$\hat{\bm{V}}_k^{gen}$与真实动作片段$\bm{V}_k^B$在时间上对齐，其中前$N$帧为可观测上下文，后$M$帧为模型生成输出。
因此，后续训练目标的定义将以$\hat{\bm{V}}_k^{gen}$为核心对象，并与真实片段中对应的生成区间进行比较。

\section{监督损失}
\label{sec:segment_losses}

在训练阶段，给定来自多模态语音动作数据集的配对样本序列：
\begin{equation}
\big(\bm{z}_t^{A},\, \bm{z}_t^{F},\, \bm{z}_t^{H},\, \bm{v}_t^{B}\big),
\end{equation}
模型的学习目标是在严格因果约束下生成与输入相匹配的上半身动作序列。
与传统离线序列预测不同，本文采用第\ref{sec:sliding_window_rollout}节所述的滑动窗口展开策略：模型在每个片段内部自回归地逐帧生成$M$帧动作，并将其拼接为片段级生成序列。

\subsection{片段级生成序列与损失计算范围}
\label{subsec:segment_level_loss_scope}

对于第$k$个训练片段，其长度为$L=N+M$（第\ref{sec:segment_construction}节），其中前$N$帧为前置动作帧，后$M$帧为模型需要生成的目标区间。
根据滑动窗口展开过程（式\eqref{eq:generated_segment}），模型得到片段生成区间的预测序列：
\begin{equation}
\hat{\bm{g}}_k = 
(\hat{\bm{v}}_{s_k+N}^{B},\ \hat{\bm{v}}_{s_k+N+1}^{B},\ \ldots,\ \hat{\bm{v}}_{s_k+L-1}^{B})
\in \mathbb{R}^{M \times d},
\label{eq:gen_segment_seq}
\end{equation}
其中$d$表示动作表示的维度（本文中使用Rot6D\cite{rot6d}，即$d=6$）。
对应的真实动作序列为：
\begin{equation}
\bm{g}_k = 
(\bm{v}_{s_k+N}^{B},\ \bm{v}_{s_k+N+1}^{B},\ \ldots,\ \bm{v}_{s_k+L-1}^{B})
\in \mathbb{R}^{M \times d}.
\label{eq:gt_segment_seq}
\end{equation}

需要强调的是，片段前$N$帧前置动作仅用于提供因果历史上下文与片段平滑过渡，其本身并非生成目标。
因此，与CaMN\cite{beatcamn}不同的是，本文的监督损失仅在片段生成区间$\{s_k+N,\ldots,s_k+L-1\}$上计算，不对前置动作帧计算任何损失项。
这是因为前置动作帧作为已知条件用于初始化历史缓存，而模型输出仅对应后续的生成区间。

\subsection{总体优化目标}
\label{subsec:total_objective}

综合考虑空间重构精度、时序平滑性以及动作分布一致性，本文的总体优化目标定义为：
\begin{equation}
\mathcal{L}_{total} =
\lambda_r  \mathcal{L}_{rec}
+ \lambda_v \mathcal{L}_{vel}
+ \lambda_a \mathcal{L}_{acc}
+ \lambda_{adv} \mathcal{L}_{adv},
\label{eq:loss_total_seg}
\end{equation}
其中$\mathcal{L}_{rec}$衡量片段生成区间的姿态重构误差，
$\mathcal{L}_{vel}$与$\mathcal{L}_{acc}$分别约束速度与加速度的连续性，
$\mathcal{L}_{adv}$表示对抗训练损失，将在第\ref{sec:adv_training}节中进一步介绍。

\subsection{姿态重构与时序平滑损失}
\label{subsec:reconstruction_smoothness_loss}

为同时保证空间重构精度与时间连续性，我们采用基于Huber误差的重构损失形式，并分别作用于姿态、速度与加速度信号。
给定任意预测序列$\hat{\bm{x}}$及其对应的真实序列$\bm{x}$，基础误差项定义为：
\begin{equation}
\mathcal{L}_{Huber}(\bm{x}, \hat{\bm{x}})
=
\beta \cdot
\mathrm{SmoothL1}
\left(
\frac{\bm{x}}{\beta},
\frac{\hat{\bm{x}}}{\beta}
\right),
\label{eq:huber_loss}
\end{equation}
其中$\mathrm{SmoothL1}(\cdot)$表示平滑L1误差，$\beta$为平滑系数，本文中设为$0.1$。

在此基础上，片段生成区间的姿态、速度与加速度损失分别定义为：
\begin{align}
\mathcal{L}_{rec} &= \mathcal{L}_{Huber}(\bm{g}_k, \hat{\bm{g}}_k), \label{eq:rec_loss}\\
\mathcal{L}_{vel} &= \mathcal{L}_{Huber}(\bm{g}_k', \hat{\bm{g}}_k'), \label{eq:vel_loss}\\
\mathcal{L}_{acc} &= \mathcal{L}_{Huber}(\bm{g}_k'', \hat{\bm{g}}_k''), \label{eq:acc_loss}
\end{align}
其中一阶与二阶时间差分$\bm{g}_k'$、$\bm{g}_k''$定义为：
\begin{equation}
\bm{g}_{k,t}' = \bm{g}_{k,t} - \bm{g}_{k,t-1}, \quad
\bm{g}_{k,t}'' = \bm{g}_{k,t}' - \bm{g}_{k,t-1}',
\label{eq:diff_def}
\end{equation}
预测序列$\hat{\bm{g}}_k'$、$\hat{\bm{g}}_k''$同理定义。

上述多尺度重构约束在自回归预测过程中能够有效缓解高频抖动与速度漂移问题，
在保证运动学精度的同时提升生成序列的时间稳定性。

\subsection{损失权重设置}
各损失项的权重系数在实验中设定为
$\lambda_r = 5\times10^{2}$，
$\lambda_v = 10^{3}$，
$\lambda_a = 10^{3}$，
$\lambda_{adv} = 10^{-1}$。

\section{对抗训练}
\label{sec:adv_training}

尽管第\ref{sec:segment_losses}节的监督损失能够约束生成序列在逐帧空间误差与局部平滑性上的一致性，但仅依赖点对点重构目标往往难以完全刻画真实动作序列的整体动力学分布。
为进一步提升生成动作的自然度与分布一致性，本文引入片段级判别器，在片段尺度上约束生成序列与真实序列的统计特性一致。

\subsection{基于拼接片段的片段级判别}
\label{subsec:disc_input}

与窗口内部的中间输出不同，本文的判别器直接以片段生成区间的拼接序列为输入。
对于第$k$个片段，生成器输出的预测序列$\hat{\bm{g}}_k$及其对应的真实序列$\bm{g}_k$定义见式\eqref{eq:gen_segment_seq}与式\eqref{eq:gt_segment_seq}，二者均为长度$M$的序列。
判别器$Dis(\cdot)$接收一段动作序列，并输出其来自真实数据分布的概率：
\begin{equation}
Dis(\bm{g}) \in (0,1).
\end{equation}
通过片段级输入，判别器能够从整体动力学角度判断生成动作的真实感，从而在节奏、能量变化与运动统计特性等层面提供补充监督信号。

\paragraph{前置动作帧的掩码策略}
需要强调的是，与CaMN\cite{beatcamn}不同，本文在对抗训练中同样不将片段前$N$帧前置动作输入判别器。
前置动作帧属于可观测上下文条件，其内容在训练阶段为真实动作，在推理阶段为历史缓存或上一片段输出；它们并非模型需要生成的目标。
因此，本文仅对生成区间$\hat{\bm{g}}_k$与$\bm{g}_k$进行对抗判别，使对抗目标严格作用于模型实际生成的部分，并与第\ref{sec:segment_losses}节的监督损失范围保持一致。

\subsection{对抗损失定义}
\label{subsec:bce_gan_loss}

判别器的训练目标是区分真实序列与生成序列，其损失定义为：
\begin{equation}
\mathcal{L}_{D} =
-\mathbb{E}_{\bm{g}_k}\big[\log Dis(\bm{g}_k)\big]
-\mathbb{E}_{\hat{\bm{g}}_k}\big[\log \big(1 - Dis(\hat{\bm{g}}_k)\big)\big].
\label{eq:disc_loss_bce}
\end{equation}
生成器则希望其输出被判别器判定为真实，从而对应的对抗损失为：
\begin{equation}
\mathcal{L}_{adv} =
-\mathbb{E}_{\hat{\bm{g}}_k}\big[\log Dis(\hat{\bm{g}}_k)\big].
\label{eq:gen_adv_loss_bce}
\end{equation}
其中$\mathbb{E}_{\bm{g}_k}$与$\mathbb{E}_{\hat{\bm{g}}_k}$分别表示对真实序列与生成序列的采样期望。
该对抗目标从分布层面鼓励生成序列在整体运动统计特性上接近真实数据，从而补充监督损失在局部误差上的约束。

\subsection{交替优化策略}
\label{subsec:alternating_optimization}

在训练过程中，本文采用交替优化方式更新生成器与判别器。
具体而言，对于每个训练批次，我们首先固定生成器参数$\theta$，最小化式\eqref{eq:disc_loss_bce}更新判别器参数；
随后固定判别器参数，最小化总体损失$\mathcal{L}_{total}$（见式\eqref{eq:loss_total_seg}）更新生成器参数，其中对抗项$\mathcal{L}_{adv}$由式\eqref{eq:gen_adv_loss_bce}给出。
通过上述训练方式，判别器不断提升对真实与生成序列的区分能力，而生成器则在监督约束与分布约束的共同作用下，逐步生成更加自然且时间一致的动作序列。

\section{本章小结}
\label{sec:chapter4_summary}

本章围绕严格因果的实时手势生成任务，系统阐述了本文的滑动窗口训练与推理策略，并给出了与之配套的片段级优化目标。
首先，我们建立了单步因果预测器作为基本计算单元：采用单向LSTM以满足严格因果约束，并在每个预测步中结合跨步循环状态与显式历史动作上下文，采用“短期显式条件 + 长期隐式记忆”的双时间尺度建模，从而提升自回归生成过程的稳定性与长期规律记忆能力。
随后，我们沿用CaMN\cite{beatcamn}的固定长度片段切割方法将长序列组织为训练样本，并在片段内部执行滑动窗口展开：通过预热阶段缓冲前置动作帧，再在生成阶段逐帧自回归预测并将输出写回历史缓存，最终拼接生成的所有动作帧得到生成序列。

在训练目标方面，本章将监督损失定义在片段生成区间的拼接输出上，采用姿态、速度与加速度的多尺度Huber约束以缓解抖动与速度漂移，并进一步引入片段级判别器以提供分布一致性的对抗监督。
本文将前置动作帧视为纯条件上下文而非生成目标，在监督损失与对抗训练中均显式移除其影响，使训练目标严格作用于模型实际生成的区间，从而与实时推理阶段的因果生成流程保持一致。